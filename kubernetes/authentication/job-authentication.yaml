kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: update-jwks
rules:
- apiGroups: [""]
  resources:
  - secrets
  - serviceaccounts
  - serviceaccounts/token
  verbs:
  - 'delete'
  - 'create'
  - 'patch'
  - 'get'

---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: update-jwks
  namespace: default
subjects:
- kind: ServiceAccount
  name: update-jwks
  namespace: default
roleRef:
  kind: Role
  name: update-jwks
  apiGroup: ""

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: update-jwks
  namespace: default

---
apiVersion: v1
data:
  main.ts: |-
    import * as oauth from 'https://deno.land/x/oauth4webapi@v2.3.0/mod.ts'
    
    const issuerUrl = Deno.env.get("ISSUER");
    const clientId = Deno.env.get("CLIENT_ID");
    
    const issuer = new URL(issuerUrl)
    const as = await oauth
        .discoveryRequest(issuer)
        .then((response) => oauth.processDiscoveryResponse(issuer, response))
    
    const client: oauth.Client = {
        client_id: clientId,
        token_endpoint_auth_method: 'none',
    }
    
    let device_code: string
    let interval: number
    let verification_uri_complete: string | undefined
    
    const parameters = new URLSearchParams()
    parameters.set('scope', 'offline_access openid')
    
    {
    
    
        const response = await oauth.deviceAuthorizationRequest(as, client, parameters)
        let challenges: oauth.WWWAuthenticateChallenge[] | undefined
        if ((challenges = oauth.parseWwwAuthenticateChallenges(response))) {
            for (const challenge of challenges) {
                console.log('challenge', challenge)
            }
            throw new Error() // Handle www-authenticate challenges as needed
        }
    
        const result = await oauth.processDeviceAuthorizationResponse(as, client, response)
        if (oauth.isOAuth2Error(result)) {
            console.log('error', result)
            throw new Error() // Handle OAuth 2.0 response body error
        }
    
        ; ({ device_code, verification_uri_complete, interval = 5 } = result)
    }
    
    // user gets shown the verification_uri and user_code, or scans a qr code formed from verification_uri_complete as input
    // user starts authenticating on his other device
    console.log(`Please login here: ${verification_uri_complete}`)
    
    function wait() {
        return new Promise((resolve) => {
            setTimeout(resolve, interval * 1000)
        })
    }
    
    let success: oauth.TokenEndpointResponse | undefined = undefined
    
    while (success === undefined) {
        await wait()
        const response = await oauth.deviceCodeGrantRequest(as, client, device_code, parameters)
        let challenges: oauth.WWWAuthenticateChallenge[] | undefined
        if ((challenges = oauth.parseWwwAuthenticateChallenges(response))) {
            for (const challenge of challenges) {
                console.log('challenge', challenge)
            }
            throw new Error() // Handle www-authenticate challenges as needed
        }
    
        const result = await oauth.processDeviceCodeResponse(as, client, response)
    
        if (oauth.isOAuth2Error(result)) {
            // response is oauth style error object
            switch (result.error) {
                case 'slow_down':
                    interval += 5
                case 'authorization_pending':
                    continue
                default:
                    console.log('error', result)
                    throw new Error() // Handle OAuth 2.0 response body error
            }
        } else {
            success = result
        }
    }
    
    if (success.refresh_token) {
        let encoder = new TextEncoder();
        let data = encoder.encode(success.refresh_token);
        Deno.writeFile("/tmp/token/refresh.jwt", data);
    } else {
        console.log("No refresh token")
        throw new Error()
    }
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: authentication-script

---
apiVersion: batch/v1
kind: CronJob
metadata:
  annotations:
  name: update-jwks
  namespace: default
spec:
  concurrencyPolicy: Allow
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: update-jwks
          containers:
          - name: update-jwks-curl
            image: curlimages/curl:latest
            imagePullPolicy: IfNotPresent
            command:
            - /bin/sh
            - -c
            - |-
              curl ${JWKS_ENDPOINT} | sed 's/"use":"sig",//g' > /tmp/secret/auth-secret
            env:
            - name: JWKS_ENDPOINT
              value: {{ .Values.postgrest.jwkEndpoint }}
            volumeMounts:
            - name: auth-secret
              mountPath: /tmp/secret
          - name: update-jwks-deno
            image: denoland/deno:latest
            imagePullPolicy: IfNotPresent
            command:
            - deno
            args: 
            - "run"
            - "--allow-read" 
            - "--allow-write"
            - "/tmp/script/main.ts"
            env:
            - name: JWKS_ENDPOINT
              value: {{ .Values.postgrest.jwkEndpoint }}
            volumeMounts:
            - name: auth-secret
              mountPath: /tmp/secret
            - name: key
              mountPath: /tmp/key
            - name: script
              mountPath: /tmp/script
          - name: update-jwks-kubctl
            image: bitnami/kubectl:latest
            imagePullPolicy: IfNotPresent
            command:
            - /bin/sh
            - -c
            - |-
              sleep 0.1
              while [ ! -f /tmp/key/rsa_public_key ]
              do
                sleep 0.1
              done
              kubectl create secret generic ${SECRET_NAME} --from-file=/tmp/secret/auth-secret -o yaml --dry-run=client | kubectl apply -f -
              kubectl create secret generic ${SECRET_NAME_PEM} --from-file=/tmp/key/rsa_public_key --from-literal=algorithm=RS256 --from-literal=key="https://auth.dashbook.dev" --from-literal=kongCredType=jwt -o yaml --dry-run=client | kubectl apply -f -
              kubectl rollout restart deployment dashbook-postgrest
              kubectl rollout restart deployment zitadel-postgrest
            env:
            - name: SECRET_NAME
              value: {{ .Values.postgrest.secretName }}
            - name: SECRET_NAME_PEM
              value: {{ .Values.kong.secretName }}
            volumeMounts:
            - name: auth-secret
              mountPath: /tmp/secret
            - name: key
              mountPath: /tmp/key
          dnsPolicy: Default
          hostNetwork: true
          restartPolicy: Never
          schedulerName: default-scheduler
          securityContext: {}
          terminationGracePeriodSeconds: 30
          dnsPolicy: Default
          hostNetwork: true
          restartPolicy: Never
          schedulerName: default-scheduler
          securityContext: {}
          terminationGracePeriodSeconds: 30
          volumes:
          - name: auth-secret
            emptyDir: {}
          - name: key
            emptyDir: {}
          - name: script
            configMap:
              name: update-jwks-script
  schedule: 0 */6 * * *
  successfulJobsHistoryLimit: 3
  suspend: false
